import sys
from typing import List

import numpy as np
from argparse import ArgumentParser, FileType

from jiwer import wer
from sacremoses import MosesTokenizer

np.random.seed(0)
mtok = MosesTokenizer(lang='en')


def get_parser() -> ArgumentParser:
    '''
    Parse arguments via command-line.
    '''
    parser = ArgumentParser('Run automatic evaluation.')
    parser.add_argument('-r', '--reference',
                        required=True,
                        type=FileType('r'),
                        help='File with reference sentences.')
    parser.add_argument('-h1', '--hypothesis1',
                        required=True,
                        type=FileType('r'),
                        help='File with first model outputs to consider.')
    parser.add_argument('-h2', '--hypothesis2',
                        default=None,
                        type=FileType('r'),
                        help='File with first model outputs to consider.')
    parser.add_argument('-n', '--num_samples',
                        default=1000,
                        type=int,
                        help='The number of bootstrap samples to draw.')
    parser.add_argument('-s', '--sample_ratio',
                        default=1,
                        type=float,
                        help='The ratio of samples to draw in each iteration.')
    return parser


def paired_bootstrap_resampling(ref: List[str],
                                hyp1: List[str],
                                hyp2: List[str],
                                num_samples: int = 1000,
                                sample_ratio: float = 1) -> None:
    '''
    Compute statistical significance with paired boostrap sampling and
    print results.

    Based on https://github.com/neubig/util-scripts/blob/master/paired-bootstrap.py
    '''

    assert(len(ref) == len(hyp1))
    assert(len(ref) == len(hyp1))

    hyp1_scores = []
    hyp2_scores = []
    wins = [0, 0, 0]
    n = len(ref)
    ids = list(range(n))

    for _ in range(num_samples):

        # Subsample the testsets
        reduced_ids = np.random.choice(ids,int(len(ids)*sample_ratio),replace=True)
        reduced_ref = [ref[i] for i in reduced_ids]
        reduced_hyp1 = [hyp1[i] for i in reduced_ids]
        reduced_hyp2 = [hyp2[i] for i in reduced_ids]

        # Calculate WER on the sample and save stats
        hyp1_score = wer(reduced_ref, reduced_hyp1)
        hyp2_score = wer(reduced_ref, reduced_hyp2)

        if hyp1_score < hyp2_score:
            wins[0] += 1
        elif hyp1_score > hyp2_score:
            wins[1] += 1
        else:
            wins[2] += 1
        hyp1_scores.append(hyp1_score)
        hyp2_scores.append(hyp2_score)

    # Print win stats
    wins = [x/float(num_samples) for x in wins]
    print('Win ratio: hyp1=%.3f, hyp2=%.3f, tie=%.3f' % (wins[0], wins[1], wins[2]))
    if wins[0] > wins[1]:
        print('(hyp1 is superior with p value p=%.3f)\n' % (1-wins[0]))
    elif wins[1] > wins[0]:
        print('(hyp2 is superior with p value p=%.3f)\n' % (1-wins[1]))

    # Print system stats
    hyp1_scores.sort()
    hyp2_scores.sort()
    print('hyp1 mean=%.3f, median=%.3f, 95%% confidence interval=[%.3f, %.3f]' %
         (np.mean(hyp1_scores), np.median(hyp1_scores), hyp1_scores[int(num_samples * 0.025)], hyp1_scores[int(num_samples * 0.975)]))
    print('hyp2 mean=%.3f, median=%.3f, 95%% confidence interval=[%.3f, %.3f]' %
         (np.mean(hyp2_scores), np.median(hyp2_scores), hyp2_scores[int(num_samples * 0.025)], hyp2_scores[int(num_samples * 0.975)]))


if __name__ == '__main__':
    '''
    Compute WER and statistical significance.
    '''

    parser = get_parser()
    args = parser.parse_args()

    ref_lines = [' '.join(mtok.tokenize(i)) for i in args.reference]
    hyp1_lines = [' '.join(mtok.tokenize(i)) for i in args.hypothesis1]

    print(f'WER hyp1: {round(wer(ref_lines, hyp1_lines)*100,2)}')

    if args.hypothesis2:
        hyp2_lines = [' '.join(mtok.tokenize(i)) for i in args.hypothesis2]
        print(f'WER hyp2: {round(wer(ref_lines, hyp2_lines)*100,2)}\n')

        paired_bootstrap_resampling(ref_lines,
                                    hyp1_lines,
                                    hyp2_lines,
                                    args.num_samples,
                                    args.sample_ratio)
